if (params$add.spikes.mt) {
MT_genes <- read.table(params$mt_genes_file)[,1]
isSpike(sce, "MT") <- rownames(sce)[rownames(sce) %in% MT_genes]
control_features[["MT"]] <- isSpike(sce, "MT")
}
if (params$add.spikes.ercc) {
isSpike(sce, "ERCC") <- grepl("^ERCC-", rownames(sce))
control_features[["ERCC"]] <- isSpike(sce, "ERCC")
}
# Calculate the quality metrics:
sce <- calculateQCMetrics(
sce, feature_controls = control_features )
# Removal of cells causing a warning:
NaN_cells <- unique(c(colnames(sce)[sce$pct_counts_ERCC == "NaN"],
colnames(sce)[sce$pct_counts_MT == "NaN"]))
sce <- sce[,!colnames(counts(sce)) %in% NaN_cells]
# Looking at the total number of RNA molecules per sample
# UMI counts were used for this experiment
hist(sce$total_counts, breaks = 100)
abline(v = params$total_counts_tresh, col = "red")
# Looking at the amount of unique genes per sample
# This is the amount with ERCC included.
hist(sce$total_features_by_counts, breaks = 100)
abline(v= params$total_feat_tresh, col = "red")
# Using Scater to plot percentages of spikes
# Only works if meta data available.
plot.list = list(
p1 = plotColData(sce, y = "total_counts", x = params$lab_col),
p2 = plotColData(sce, y = "total_features_by_counts", x = params$lab_col)
)
# Add ERCC to multiplot if present
if (params$add.spikes.ercc) {
plot.list[['p3']] <- plotColData(sce,
x = "total_features_by_counts",
y = "pct_counts_ERCC", colour = params$lab_col)
}
if (params$add.spikes.mt) {
plot.list[['p4']] <- plotColData(sce,
x = "total_features_by_counts",
y = "pct_counts_MT", colour = params$lab_col)
}
multiplot( plotlist = plot.list, cols=2)
#---------------------------
## Manually set thresholds for filtering of the cells:
#---------------------------
# Filter library-size and the total amount of genes on the thresholds shown
# above in the histogram.
base.filters <- c("filter_by_expr_features",
"filter_by_total_counts",
"filter_by_ercc",
"filter_by_mt")
filters <- vector("list",length(base.filters))
names(filters) <- base.filters
#Add base filters
filters[["filter_by_expr_features"]] <-
sce$total_features_by_counts >= params$total_feat_tresh
filters[["filter_by_total_counts"]] <-
sce$total_counts >= params$total_counts_tresh
#Optional filter conditions
if (params$add.spikes.ercc) {
filters[["filter_by_ercc"]] <-
sce$pct_counts_ERCC < params$ercc_pct_max
}
if (params$add.spikes.mt) {
filters[["filter_by_mt"]] <-
sce$pct_counts_MT < params$mt_pct_max
}
#Reduce filtered logis
sce$use <- Reduce("&", Filter(Negate(is.null), filters))
# Amount of cells removed per filtering:
table(filters[["filter_by_expr_features"]])
table(filters[["filter_by_total_counts"]])
table(filters[["filter_by_ercc"]])
table(filters[["filter_by_mt"]])
# Result of manual filtering with set tresholds
# TRUE are considered healthy cells:
table(sce$use)
# The quality check-passing cells are stored in the SCE-object in $use selection
# of the counts table.
# Create the quality-checked dataset:
sce_qc <- sce[, colData(sce)$use]
dim(sce_qc)
#---------------------------
## Filtering the genes
#---------------------------
# You do the filtering of the genes after selecting the healthy cells, because
# some genes might only be detected in poor quality cells
# Create the quality-checked dataset:
keep_feature <- rowSums(counts(sce_qc) >= params$gene_tresh) >= params$amount_cells_expr
sce_qc <- sce_qc[keep_feature,]
genes_expressed <- sum(keep_feature==TRUE)
write.table(paste(params$resultsdir,"spliced_qc_counts.tsv",sep="/"), col.names = NA, quote = FALSE)
saveRDS(sce_qc, file = paste(params$resultsdir,"spliced_qc_counts.rds",sep="/"))
#saveRDS(sce, file = "qc_counts.rds")
pdf(paste(params$resultsdir,"Histograms_before+aftercellsFiltering.pdf",sep="/"))
par(mfrow=c(2,2))
hist(sce$total_counts, breaks = 100)
abline(v = params$total_counts_tresh, col = "red")
hist(sce$total_features_by_counts, breaks = 100)
abline(v= params$total_feat_tresh, col = "red")
hist(sce_qc$total_counts, breaks = 100)
abline(v = params$total_counts_tresh, col = "red")
hist(sce_qc$total_features_by_counts, breaks = 100)
abline(v= params$total_feat_tresh, col = "red")
dev.off()
#Create MT plot before and after filtering
if(params$add.spikes.mt) {
pdf(paste(params$resultsdir,"MT_before+aftercellsFiltering.pdf", sep="/"))
par(mfrow=c(2,2))
print(plotColData(sce,
x = "total_features_by_counts",
y = "pct_counts_MT", colour = params$lab_col))
print(plotColData(sce_qc,
x = "total_features_by_counts",
y = "pct_counts_MT", colour = params$lab_col))
dev.off()
}
#Create ERCC plot before and after filltering
if (params$add.spikes.ercc) {
pdf(paste(params$resultsdir,"ERCC_before+aftercellsFiltering.pdf", sep="/"))
par(mfrow=c(2,2))
print(plotColData(sce,
x = "total_features_by_counts",
y = "pct_counts_ERCC", colour = params$lab_col))
print(plotColData(sce_qc,
x = "total_features_by_counts",
y = "pct_counts_ERCC", colour = params$lab_col))
dev.off()
}
#------------------------------
# Filter endogenous (add scenario for alle qc combinaties)
#------------------------------
# load the filtered dataset:
#sce_qc <- readRDS("qc_counts.rds")
endo_genes <- !rowData(sce_qc)$is_feature_control
table(endo_genes)
# Make a object with only the endogenous genes to look for confounders
sce_endo <- sce_qc[endo_genes,]
reducedDim(sce_qc) <- NULL
# vignette-qc.html#identifying-outliers-on-all-qc-metrics
plotExprsFreqVsMean(sce_endo)
# The reads consumed by the top 50 expressed genes:
plotHighestExprs(sce_qc)
# Plotting the raw data without any transformation.
sce_endo <- runPCA(
sce_endo,
ncomponents = 50,
exprs_values = "counts"
)
plotReducedDim(sce_endo, use_dimred = "PCA",
colour_by = params$lab_col,
size_by = "total_features_by_counts")
# The PCA data is stored in the reducedDimNames as a "PCA_coldata" entry, if
# use_coldata = TRUE in runPCA(). If use_coldata = FALSE, this will be stored in
# "PCA"
reducedDimNames(sce_endo)
seuset <-
CreateSeuratObject(
counts = counts(sce_endo),
assay = "sf",
meta.data = as.data.frame(colData(sce_endo)[, 1:(pheno_len + 1)])
)
seuset <-
CreateSeuratObject(
counts = counts(sce_endo),
assay = "sf",
meta.data = as.data.frame(colData(sce_endo)[, 1:(pheno_len + 1)])
)
if (mode == "velocity") {
norm.rmd <- ifelse(params$run.sct, "analysis-sct.Rmd", "analysis-norm-legacy.Rmd")
} else {
norm.rmd <- "analysis-sct-quant.Rmd"
}
knitr::opts_knit$set(output.dir = here::here())
res <- knitr::knit_child(norm.rmd, quiet = TRUE)
if (mode == "velocity") {
norm.rmd <- ifelse(params$run.sct, "analysis-sct.Rmd", "analysis-norm-legacy.Rmd")
} else {
norm.rmd <- "analysis-sct-quant.Rmd"
}
knitr::opts_knit$set(output.dir = here::here())
res <- knitr::knit_child(norm.rmd, quiet = TRUE)
if (mode == "velocity") {
norm.rmd <- ifelse(params$run.sct, "analysis-sct.Rmd", "analysis-norm-legacy.Rmd")
} else {
norm.rmd <- "analysis/analysis-sct-quant.Rmd"
}
knitr::opts_knit$set(output.dir = here::here())
res <- knitr::knit_child(norm.rmd, quiet = TRUE)
cat(res, sep = '\n')
#PrintPCA(object = seuset.scnorm, pcs.print = 1:5, genes.print = 5, use.full = FALSE)
VizDimLoadings(object = seuset, dims = 1:10, reduction = "pca")
VizDimLoadings(object = seuset, dims = 10:20, reduction = "pca")
pdf(paste(
params$resultsdir,
paste0("VizPCAplot_PCs1-", params$pcs_max_hvg, ".pdf"),
sep = "/"
),
width = 20,
height = 60)
VizDimLoadings(object = seuset, dims = 1:params$pcs_max_hvg, reduction = "pca")
dev.off()
DimPlot(object = seuset, reduction = "pca", group.by = params$lab_col)
# Helping in choosing the PCs to include in the analysis
DimHeatmap(
object = seuset,
dims = 1:5,
cells = 500,
balanced = TRUE
)
pdf(paste(
params$resultsdir,
paste0("PCheatmap_PCs1-", params$pcs_max_hvg, ".pdf"),
sep = "/"
),
width = 20,
height = 60)
DimHeatmap(
object = seuset,
dims = 1:params$pcs_max_hvg,
cells = 500,
balanced = TRUE
)
dev.off()
ElbowPlot(object = seuset, ndims = 35)
#Generating a combined UMAP plot with various defined settings. Only a legend in
#the first plotted (since this will be the same for the others). Generating a
#combined plot with only a legend in the first plotted (since this will be the
#same for the others) # This could be done nicer with a loop probably, in which
#for each principle component of interest, there is a umap run, and 2 different
#labels are shown for it.
combine_umap_plot <- function(umap, pcs_for_overview){
plot.list <- list()
for (i in (1:length(pcs_for_overview))){
seuset <- RunUMAP(seuset, dims = 1:pcs_for_overview[i])
dimnr <- as.character(pcs_for_overview[i])
print(dimnr)
if (i == 1){
plot.list[[dimnr]] <-
DimPlot(seuset,
reduction = "umap",
group.by = umap,
combine = TRUE) + ggtitle(paste0("UMAP 1:", dimnr))
} else {
plot.list[[dimnr]] <-
DimPlot(seuset,
reduction = "umap",
group.by = umap,
combine = TRUE) + ggtitle(paste0("UMAP 1:", dimnr)) + theme(legend.position = "none")
}
}
#Generate combined plot for umap variabel
return(plot.list)
}
#Apply to each defined umap component in label vector
for (umap in label.vector) {
plot.list <- combine_umap_plot(umap, pcs_for_overview)
pdf(
paste0(
params$resultsdir,
"/",
"UMAPdiffsettings_",
paste(as.character(pcs_for_overview), collapse = "-"),
umap,
".pdf"
),
width = 20,
height = 15
)
print(CombinePlots(plot.list, nrows = round(length(pcs_for_overview)/3)))
dev.off()
}
#Custom listings markdown template: https://stackoverflow.com/questions/21402157/colour-for-r-code-chunk-in-listings-package/21468454
# Plate based assays:
# Make sure the plates to combine all have the same amount of "_" separated fields in their folder names.
# These fields will be used to set up the phenodata columns. - The Combined ID per plate, will be used for labelling in figures.
# Droplet based assay (experimental)
# You can provide custom meta-data if you dont want to derive the phenotype fields from sample names when extract_phenotypes is set to FALSE.
# Set up a .csv file with minimally the following base columns: Sample,Genome,Barcode,Library.
# The sample,genome and barcode columns will be combined to match the barcode ids in the spliced/unspliced count matrix.
# Additional columns can be provided for statistical analysis, such as umap embeddings. An example can be found in the data folder (pbmc_meta_test.csv).
# Set the meta_data parameter to the path of the csv file
here::set_here()
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
source(here::here("analysis/utils.R"),local = knitr::knit_global())
system(paste("mkdir -p ", params$resultsdir))
# Loading the important repositories #
require("devtools")
library(ggplot2)
library(dplyr)
library(tidyr)
library(mvoutlier)
library(limma)
library(knitr)
library(SingleCellExperiment)
library(scater)
library(Seurat)
library(scran)
library(RColorBrewer)
library(plot3D)
## unlist parameters ##
label.vector = unlist(strsplit(params$umap_cols,","))
# Unique combined ID per plate, for visualization purposes
extract_meta_columns = unlist(strsplit(params$extract_meta_columns,","))
# Combined columns for plotting in meta data
meta_group_id = unlist(strsplit(params$meta_group_id,","))
# PCs used for different UMAP representations
pcs_for_overview = as.integer(unlist(strsplit(params$pcs_for_overview,",")))
#Checking variability explained by confounding factors
confounders_to_test = unlist(strsplit(params$confounders_to_test,","))
# Marker genes for violin plots
#explore_violin = c("SOX2","GAPDH")
# Regression performed on the following variables:"
vars_to_regress_sf = unlist(strsplit(params$vars_to_regress_sf,","))
vars_to_regress_uf = unlist(strsplit(params$vars_to_regress_uf,","))
#### Small sanitychecks #####
if (params$extract_meta_columns != "" && params$meta_data !="") {
stop("Provider either a meta-data.csv file or set extract_meta_columns but not both!")
}
setwd("~/Documents/Projects/R/scRNA-seq")
#Custom listings markdown template: https://stackoverflow.com/questions/21402157/colour-for-r-code-chunk-in-listings-package/21468454
# Plate based assays:
# Make sure the plates to combine all have the same amount of "_" separated fields in their folder names.
# These fields will be used to set up the phenodata columns. - The Combined ID per plate, will be used for labelling in figures.
# Droplet based assay (experimental)
# You can provide custom meta-data if you dont want to derive the phenotype fields from sample names when extract_phenotypes is set to FALSE.
# Set up a .csv file with minimally the following base columns: Sample,Genome,Barcode,Library.
# The sample,genome and barcode columns will be combined to match the barcode ids in the spliced/unspliced count matrix.
# Additional columns can be provided for statistical analysis, such as umap embeddings. An example can be found in the data folder (pbmc_meta_test.csv).
# Set the meta_data parameter to the path of the csv file
here::set_here()
print(here::here())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
source(here::here("analysis/utils.R"),local = knitr::knit_global())
system(paste("mkdir -p ", params$resultsdir))
# Loading the important repositories #
require("devtools")
library(ggplot2)
library(dplyr)
library(tidyr)
library(mvoutlier)
library(limma)
library(knitr)
library(SingleCellExperiment)
library(scater)
library(Seurat)
library(scran)
library(RColorBrewer)
library(plot3D)
## unlist parameters ##
label.vector = unlist(strsplit(params$umap_cols,","))
# Unique combined ID per plate, for visualization purposes
extract_meta_columns = unlist(strsplit(params$extract_meta_columns,","))
# Combined columns for plotting in meta data
meta_group_id = unlist(strsplit(params$meta_group_id,","))
# PCs used for different UMAP representations
pcs_for_overview = as.integer(unlist(strsplit(params$pcs_for_overview,",")))
#Checking variability explained by confounding factors
confounders_to_test = unlist(strsplit(params$confounders_to_test,","))
# Marker genes for violin plots
#explore_violin = c("SOX2","GAPDH")
# Regression performed on the following variables:"
vars_to_regress_sf = unlist(strsplit(params$vars_to_regress_sf,","))
vars_to_regress_uf = unlist(strsplit(params$vars_to_regress_uf,","))
#### Small sanitychecks #####
if (params$extract_meta_columns != "" && params$meta_data !="") {
stop("Provider either a meta-data.csv file or set extract_meta_columns but not both!")
}
#Custom listings markdown template: https://stackoverflow.com/questions/21402157/colour-for-r-code-chunk-in-listings-package/21468454
# Plate based assays:
# Make sure the plates to combine all have the same amount of "_" separated fields in their folder names.
# These fields will be used to set up the phenodata columns. - The Combined ID per plate, will be used for labelling in figures.
# Droplet based assay (experimental)
# You can provide custom meta-data if you dont want to derive the phenotype fields from sample names when extract_phenotypes is set to FALSE.
# Set up a .csv file with minimally the following base columns: Sample,Genome,Barcode,Library.
# The sample,genome and barcode columns will be combined to match the barcode ids in the spliced/unspliced count matrix.
# Additional columns can be provided for statistical analysis, such as umap embeddings. An example can be found in the data folder (pbmc_meta_test.csv).
# Set the meta_data parameter to the path of the csv file
here::set_here()
print(here::here())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
source(here::here("analysis/utils.R"),local = knitr::knit_global())
system(paste("mkdir -p ", params$resultsdir))
# Loading the important repositories #
require("devtools")
library(ggplot2)
library(dplyr)
library(tidyr)
library(mvoutlier)
library(limma)
library(knitr)
library(SingleCellExperiment)
library(scater)
library(Seurat)
library(scran)
library(RColorBrewer)
library(plot3D)
## unlist parameters ##
label.vector = unlist(strsplit(params$umap_cols,","))
# Unique combined ID per plate, for visualization purposes
extract_meta_columns = unlist(strsplit(params$extract_meta_columns,","))
# Combined columns for plotting in meta data
meta_group_id = unlist(strsplit(params$meta_group_id,","))
# PCs used for different UMAP representations
pcs_for_overview = as.integer(unlist(strsplit(params$pcs_for_overview,",")))
#Checking variability explained by confounding factors
confounders_to_test = unlist(strsplit(params$confounders_to_test,","))
# Marker genes for violin plots
#explore_violin = c("SOX2","GAPDH")
# Regression performed on the following variables:"
vars_to_regress_sf = unlist(strsplit(params$vars_to_regress_sf,","))
vars_to_regress_uf = unlist(strsplit(params$vars_to_regress_uf,","))
#### Small sanitychecks #####
if (params$extract_meta_columns != "" && params$meta_data !="") {
stop("Provider either a meta-data.csv file or set extract_meta_columns but not both!")
}
#Custom listings markdown template: https://stackoverflow.com/questions/21402157/colour-for-r-code-chunk-in-listings-package/21468454
# Plate based assays:
# Make sure the plates to combine all have the same amount of "_" separated fields in their folder names.
# These fields will be used to set up the phenodata columns. - The Combined ID per plate, will be used for labelling in figures.
# Droplet based assay (experimental)
# You can provide custom meta-data if you dont want to derive the phenotype fields from sample names when extract_phenotypes is set to FALSE.
# Set up a .csv file with minimally the following base columns: Sample,Genome,Barcode,Library.
# The sample,genome and barcode columns will be combined to match the barcode ids in the spliced/unspliced count matrix.
# Additional columns can be provided for statistical analysis, such as umap embeddings. An example can be found in the data folder (pbmc_meta_test.csv).
# Set the meta_data parameter to the path of the csv file
here::set_here()
print(here::here())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
source(here::here("analysis/utils.R"),local = knitr::knit_global())
system(paste("mkdir -p ", params$resultsdir))
# Loading the important repositories #
require("devtools")
library(ggplot2)
library(dplyr)
library(tidyr)
library(mvoutlier)
library(limma)
library(knitr)
library(SingleCellExperiment)
library(scater)
library(Seurat)
library(scran)
library(RColorBrewer)
library(plot3D)
## unlist parameters ##
label.vector = unlist(strsplit(params$umap_cols,","))
# Unique combined ID per plate, for visualization purposes
extract_meta_columns = unlist(strsplit(params$extract_meta_columns,","))
# Combined columns for plotting in meta data
meta_group_id = unlist(strsplit(params$meta_group_id,","))
# PCs used for different UMAP representations
pcs_for_overview = as.integer(unlist(strsplit(params$pcs_for_overview,",")))
#Checking variability explained by confounding factors
confounders_to_test = unlist(strsplit(params$confounders_to_test,","))
# Marker genes for violin plots
#explore_violin = c("SOX2","GAPDH")
# Regression performed on the following variables:"
vars_to_regress_sf = unlist(strsplit(params$vars_to_regress_sf,","))
vars_to_regress_uf = unlist(strsplit(params$vars_to_regress_uf,","))
#### Small sanitychecks #####
if (params$extract_meta_columns != "" && params$meta_data !="") {
stop("Provider either a meta-data.csv file or set extract_meta_columns but not both!")
}
#Custom listings markdown template: https://stackoverflow.com/questions/21402157/colour-for-r-code-chunk-in-listings-package/21468454
# Plate based assays:
# Make sure the plates to combine all have the same amount of "_" separated fields in their folder names.
# These fields will be used to set up the phenodata columns. - The Combined ID per plate, will be used for labelling in figures.
# Droplet based assay (experimental)
# You can provide custom meta-data if you dont want to derive the phenotype fields from sample names when extract_phenotypes is set to FALSE.
# Set up a .csv file with minimally the following base columns: Sample,Genome,Barcode,Library.
# The sample,genome and barcode columns will be combined to match the barcode ids in the spliced/unspliced count matrix.
# Additional columns can be provided for statistical analysis, such as umap embeddings. An example can be found in the data folder (pbmc_meta_test.csv).
# Set the meta_data parameter to the path of the csv file
here::set_here()
knitr::opts_knit$set(root.dir = here::here())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
source(here::here("analysis/utils.R"),local = knitr::knit_global())
system(paste("mkdir -p ", params$resultsdir))
# Loading the important repositories #
require("devtools")
library(ggplot2)
library(dplyr)
library(tidyr)
library(mvoutlier)
library(limma)
library(knitr)
library(SingleCellExperiment)
library(scater)
library(Seurat)
library(scran)
library(RColorBrewer)
library(plot3D)
## unlist parameters ##
label.vector = unlist(strsplit(params$umap_cols,","))
# Unique combined ID per plate, for visualization purposes
extract_meta_columns = unlist(strsplit(params$extract_meta_columns,","))
# Combined columns for plotting in meta data
meta_group_id = unlist(strsplit(params$meta_group_id,","))
# PCs used for different UMAP representations
pcs_for_overview = as.integer(unlist(strsplit(params$pcs_for_overview,",")))
#Checking variability explained by confounding factors
confounders_to_test = unlist(strsplit(params$confounders_to_test,","))
# Marker genes for violin plots
#explore_violin = c("SOX2","GAPDH")
# Regression performed on the following variables:"
vars_to_regress_sf = unlist(strsplit(params$vars_to_regress_sf,","))
vars_to_regress_uf = unlist(strsplit(params$vars_to_regress_uf,","))
#### Small sanitychecks #####
if (params$extract_meta_columns != "" && params$meta_data !="") {
stop("Provider either a meta-data.csv file or set extract_meta_columns but not both!")
}
